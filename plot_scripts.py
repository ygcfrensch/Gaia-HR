import logging
import numpy as np
import matplotlib as mpl
import astropy.units as u
import matplotlib.pyplot as plt
from astropy.table import Table
from astroquery.gaia import Gaia
from astroquery.simbad import Simbad

logging.getLogger("astroquery").setLevel(logging.ERROR)
logging.getLogger("astropy").setLevel(logging.ERROR)

def get_data(maxdist, dereddened=True, gaia_source='gaiadr3.gaia_source'):
    """
    Load Gaia data and compute absolute (dereddened) magnitudes up to a maximum distance.

    Parameters
    ----------
    maxdist : float
        Maximum distance of stars to include [pc].
    dereddened : bool, optional
        If True, correct magnitudes for extinction. Default is True.
    gaia_source : str, optional
        Gaia catalog to use (default 'gaiadr3.gaia_source').

    Returns
    -------
    GMAG : numpy.ndarray
        Absolute G-band magnitudes of selected stars [mag].
    GBPGRP : numpy.ndarray
        Color indices (G_BP - G_RP) [mag].
    tab : astropy.table.Table
        Gaia data table filtered to maxdist.
    """
    tab = Table.read(f'data/{gaia_source.split('.')[0]}_HR_parameters.fits')
	
    parallax = tab['parallax']*1e-3 # arcsec
    
    dist = 1/parallax # parsec
    filt = (dist <= maxdist)
    
    tab = tab[filt]
    dist = dist[filt]

    phot_g_mean_mag = tab['phot_g_mean_mag']
    GBPGRP = (tab['phot_bp_mean_mag'] - tab['phot_rp_mean_mag'])
    
    if dereddened:
        phot_g_mean_mag -= tab['ag_gspphot']
        GBPGRP -= tab['ebpminrp_gspphot']
    
    GMAG = phot_g_mean_mag - 5 * np.log10(dist) + 5
    return(GMAG, GBPGRP, tab)
    
def background_data_scatter(maxdist=100, cmap='viridis', markersize=1, dereddened=True, logg_or_mh='logg', gaia_source='gaiadr3.gaia_source'):
    """
    Plot the HR diagram for stars within a given maximum distance.

    Parameters
    ----------
    maxdist : float, optional
        Maximum distance to include stars [pc]. Default is 100.
    cmap : str, optional
        Matplotlib colormap to use for data. Default is 'viridis'.
    markersize : float, optional
        Size of the scatter plot markers. Default is 1.
    dereddened : bool, optional
        If True, magnitudes and colors are corrected for extinction. Default is True.
    logg_or_mh : {'logg', 'MH'}, optional
        Parameter used for color-coding:
        - 'logg': use surface gravity log(g)
        - 'MH': use metallicity [M/H]
        Default is 'logg'.
    gaia_source : str, optional
        Gaia catalog to use. Default is 'gaiadr3.gaia_source'.

    Returns
    -------
    HR_colorbar : matplotlib.colorbar.Colorbar
        Colorbar object for the plotted stars, useful for scaling additional markers.
    """
    GMAG, GBPGRP, tab = get_data(maxdist, dereddened, gaia_source)
    
    if logg_or_mh == 'logg':
        zaxis = tab['logg_gspphot']
        cb_label = r'$\log(g)$ [$\mathrm{cm\,s}^{-2}$]'
    elif logg_or_mh == 'MH':
        zaxis = tab['mh_gspphot']
        cb_label = r'[M/H] [dex]'

    plt.figure(figsize=(8,6))
    plt.scatter(GBPGRP, GMAG, c=zaxis, cmap=cmap, s=markersize, marker='.')
    HR_colorbar = plt.colorbar()
    HR_colorbar.set_label(cb_label)
    plt.ylabel(r'$G$')
    plt.xlabel(r'$(G_{\rm BP}-G_{\rm RP})$')
    plt.gca().invert_yaxis()
    
    print('Number of stars within maximum distance (%i pc): %i'%(maxdist, len(GMAG)))
    return(HR_colorbar)
    
def standard_plot_ticks():
    """
    Configure standard ticks for the HR diagram and add a secondary x-axis for effective temperature.

    Sets:
    - Major and minor tick lengths and directions
    - Label sizes
    - Secondary x-axis with approximate Teff ticks corresponding to G_BP - G_RP colors
    """
    plt.tick_params(direction='in', length=8, which='major', pad=8)
    plt.minorticks_on()
    plt.tick_params(direction='in', length=4, which='minor')

    ax = plt.gca()
    ax2 = ax.twiny()
    gbpgrp = GSPPHOT_Teff_to_gbpgrp(np.array([3000, 4000, 5000, 7000, 30000]))
    ax2.set_xticks(gbpgrp, [3000, 4000, 5000, 7000, 30000])
    ax2.set_xlim(ax.get_xlim())
    ax2.set_xlabel(r'$T_{\rm eff}$ [K]')

def Gaia_specific_star(target_name, HR_colorbar, Gaia_ID=None, RA=None, Dec=None, 
					   gaia_source='gaiadr3.gaia_source', markersize=7, markershape='s', 
					   cmap='viridis', text_dx=None, text_dy=None, dereddened=True, verbose=True, 
					   logg_or_mh='logg', fontweight='normal'):
    """
    Overplot an individual star on the existing HR diagram created with background_data_scatter().

    Parameters
    ----------
    target_name : str
        Name of the star to query in SIMBAD.
    HR_colorbar : matplotlib.colorbar.Colorbar
        Colorbar generated by background_data_scatter() for consistent color scaling.
    Gaia_ID : int, optional
        Gaia source ID. Required if SIMBAD cannot resolve it.
    RA : float, optional
        Right ascension [deg]. Required if SIMBAD cannot resolve it.
    Dec : float, optional
        Declination [deg]. Required if SIMBAD cannot resolve it.
    markersize : int, optional
        Size of the target marker. Default is 7.
    markershape : str, optional
        Marker shape (matplotlib compatible). Default is 's'.
    cmap : str, optional
        Colormap for the target color. Default is 'viridis'.
    text_dx : float, optional
        Horizontal offset in points for annotation.
    text_dy : float, optional
        Vertical offset in points for annotation.
    dereddened : bool, optional
        If True, deredden the magnitudes for this target. Default is True.
    verbose : bool, optional
        If True, print status messages. Default is True.
    logg_or_mh : {'logg', 'MH'}, optional
        Parameter used for marker color: 'logg' or 'MH'. Default is 'logg'.
    fontweight : {'normal', 'bold', 'italic'}, optional
        Font weight for annotation text. Default is 'normal'.

    Returns
    -------
    target_dict : dict
        Dictionary with the following keys:
        - 'GMAG' : float, absolute G magnitude
        - 'GBPGRP' : float, color index G_BP - G_RP
        - 'logg' : float, surface gravity log(g)
        - 'Teff' : float, effective temperature [K]
        - '[M/H]' : float, metallicity [dex]

    Notes
    -----
    - Prints warnings if Gaia RUWE >= 1.4 or parallax_over_error < 10.
    - If Gaia_ID, RA, or Dec cannot be resolved, the function exits without plotting.
    - Use both text_dx and text_dy to annotate the target.
    """
    quit = False
    if verbose:
    	print('\n' + target_name)
    
    # Searches for Gaia ID
    sid = Simbad.query_objectids(target_name)

    if Gaia_ID == None:
        for ID in sid['id']:
            if ('Gaia DR3' in ID) & ('gaiadr3' in gaia_source):
                Gaia_ID = int(ID.replace('Gaia DR3 ', ''))
            elif ('Gaia DR2' in ID) & ('gaiadr2' in gaia_source):
                Gaia_ID = int(ID.replace('Gaia DR2 ', ''))
        if Gaia_ID == None:
            if verbose:
                print('Gaia ID not found via Simbad, please provide Gaia ID.')
            quit = True

    # Searches for RA & Dec
    if (RA == None):
        spos = Simbad.query_object(target_name)
        RA = spos['ra'].value # deg
        if len(RA) == 0:
            if verbose:
                print('RA not found via Simbad, please provide RA.')
            quit = True

    if Dec == None:
        Dec = spos['dec'].value # deg
        if len(Dec) == 0:
            if verbose:
                print('Dec not found via Simbad, please provide Dec.')
            quit = True

    # If Gaia ID, RA, or Dec is not found, code stops
    if quit:
        return()

    # Query DR3 parallax etc. 
    i = 50; sid = []
    while (Gaia_ID not in sid) & (i <= 1000):
        query = """SELECT source_id, ra, dec, parallax, logg_gspphot, teff_gspphot, phot_g_mean_mag, phot_rp_mean_mag, phot_bp_mean_mag, mh_gspphot, parallax_error, ruwe, parallax_over_error, ag_gspphot, ebpminrp_gspphot
        FROM %s
        WHERE 
        CONTAINS(
            POINT('ICRS', %s.ra, %s.dec),
            CIRCLE('ICRS', %.6f, %.6f, %.6f)
        )=1"""%(gaia_source, gaia_source, gaia_source, RA, Dec, 0.0005555555555555556*i)

        job = Gaia.launch_job(query)
        gtable = job.get_results() 
        sid = gtable['source_id'].value
        i += 50
    
    # Get value corresponding to Gaia ID
    x = (sid == Gaia_ID)
    if sum(sid == Gaia_ID) == 0:
        return()

    if verbose:
        print(f'Gaia ID: {sid[x][0]}')

    parallax = gtable['parallax'][x].value * 1e-3 # arcsec
    dist = 1/parallax # parsec

    phot_g_mean_mag = gtable['phot_g_mean_mag'][x].value
    GBPGRP = (gtable['phot_bp_mean_mag'][x].value - gtable['phot_rp_mean_mag'][x].value)
    
    if dereddened:
        phot_g_mean_mag -= gtable['ag_gspphot'][x].value
        GBPGRP -= gtable['ebpminrp_gspphot'][x].value

    GMAG = phot_g_mean_mag - 5 * np.log10(dist) + 5
    
    # Warnings
    if verbose:
        if gtable['ruwe'][x].value >= 1.4:
            print('RUWE >= 1.4!')
        if gtable['parallax_over_error'][x].value < 10:
            print('parallax_over_error < 10')
    
    # sigG = np.abs(dist * (5/np.log(10))) * (gtable['parallax_error'][x]*1e-3) # for if you want to plot errorbars
    logg = gtable['logg_gspphot'][x]
    teff = gtable['teff_gspphot'][x]
    MH = gtable['mh_gspphot'][x]
    
    if logg_or_mh == 'logg':
        zaxis = logg
    elif logg_or_mh == 'MH':
        zaxis = MH
    
    TEFF = GSPPHOT_gbpgrp_to_Teff(GBPGRP[0])
    
    if teff.value[0] == teff.value[0]:
	    print('\t Teff (Gaia GSP-Phot): %.2f'%(teff.value[0]))
    if (TEFF == TEFF) & (dereddened):
        print('\t Teff (GBP-GRP approximation): %.2f'%(TEFF))
    target_dict = {'GMAG': GMAG, 'GBPGRP': GBPGRP, 'logg': logg, 'Teff': TEFF, '[M/H]': MH}

    cmap = mpl.colormaps.get_cmap(cmap)
    COL = cmap( ( zaxis - HR_colorbar.vmin ) / ( HR_colorbar.vmax - HR_colorbar.vmin ) ); Z = 2
    if zaxis.mask == True:
        COL = 'grey'
        Z = 1
        
    plt.errorbar(GBPGRP, GMAG, zorder=Z, marker=markershape, linewidth=1, markerfacecolor=COL, markeredgecolor='black', markersize=markersize)
    if (text_dx != None) & (text_dy != None):
        plt.gca().annotate(str(target_name), xy=(GBPGRP, GMAG), xycoords='data',\
                           xytext=(text_dx, text_dy), textcoords='offset points',\
                           arrowprops=dict(arrowstyle='->'), fontweight=fontweight)
    elif (text_dx != None) | (text_dy != None):
        print('Define both text_dx and text_dy if you want to annotate this target.')
    return(target_dict)
   
def GSPPHOT_gbpgrp_to_Teff(gbpgrp): 
    """
    Approximate the effective temperature from Gaia G_BP - G_RP color using GSPPHOT calibration.

    Parameters
    ----------
    gbpgrp : float or array-like
        Color index G_BP - G_RP [mag].

    Returns
    -------
    teff : float or np.ndarray
        Approximated effective temperature [K].
    """
    A = 6.76492918e+03
    B = -1.16645126e+03
    C = -7.21165676e-01
    teff = A / (gbpgrp - C) - B
    return(teff)
    
def GSPPHOT_Teff_to_gbpgrp(teff):
    """
    Approximate the Gaia G_BP - G_RP color from an effective temperature using GSPPHOT calibration.

    Parameters
    ----------
    teff : float or array-like
        Effective temperature [K].

    Returns
    -------
    gbpgrp : float or np.ndarray
        Approximated G_BP - G_RP color index [mag].
    """
    A = 6.76492918e+03
    B = -1.16645126e+03
    C = -7.21165676e-01
    gbpgrp = A / (teff + B) + C  
    return(gbpgrp)